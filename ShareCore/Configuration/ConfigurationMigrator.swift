//
//  ConfigurationMigrator.swift
//  ShareCore
//

import Foundation

/// Migrates persisted `AppConfiguration` from older versions to the current version.
///
/// Each migration step transforms the configuration one minor version at a time
/// (e.g. 1.1.0 -> 1.2.0). Steps are applied sequentially so that any saved
/// configuration â€” regardless of how old â€” can reach `AppConfiguration.currentVersion`.
public enum ConfigurationMigrator {

    /// Migrate `config` to `AppConfiguration.currentVersion`.
    /// Returns the migrated configuration and a flag indicating whether any
    /// migration was actually performed.
    public static func migrateIfNeeded(
        _ config: AppConfiguration
    ) -> (config: AppConfiguration, didMigrate: Bool) {
        var result = config
        var didMigrate = false

        // 1.1.x -> 1.2.0
        if versionCompare(result.version, isLessThan: "1.2.0") {
            result = migrate_1_1_to_1_2(result)
            didMigrate = true
        }

        // 1.2.x -> 1.3.0
        if versionCompare(result.version, isLessThan: "1.3.0") {
            result = migrate_1_2_to_1_3(result)
            didMigrate = true
        }

        return (result, didMigrate)
    }

    // MARK: - 1.1.x -> 1.2.0

    /// Migration: replace old-format translate prompts with the new
    /// `{text}` / `{targetLanguage}` template.
    private static func migrate_1_1_to_1_2(
        _ config: AppConfiguration
    ) -> AppConfiguration {
        let translateName = NSLocalizedString(
            "Translate",
            comment: "Name of the translate action"
        )

        let newTranslatePrompt =
            #"Translate: "{text}" to {targetLanguage} with tone: fluent"#

        var migrated = config
        migrated.version = "1.2.0"

        migrated.actions = migrated.actions.map { entry in
            guard entry.name == translateName else { return entry }

            // Only replace if the prompt matches a known old format.
            // User-customized prompts are left untouched.
            if isOldTranslatePrompt(entry.prompt) {
                var updated = entry
                updated.prompt = newTranslatePrompt
                Logger.debug("[Migrator] Migrated translate prompt for action '\(entry.name)'")
                return updated
            }

            return entry
        }

        Logger.debug("[Migrator] Migration 1.1 -> 1.2 complete")
        return migrated
    }

    /// Recognizes old translate prompt formats that should be migrated.
    ///
    /// Known old patterns:
    /// - `"If input is in <lang>, translate to <lang>; otherwise translate to <lang>. â€¦"`
    ///   (the format generated by the pre-refactor `ManagedActionTemplate`)
    static func isOldTranslatePrompt(_ prompt: String) -> Bool {
        prompt.hasPrefix("If input is in ")
    }

    // MARK: - 1.2.x -> 1.3.0

    /// Migration: remove `{fallbackLanguage}` / `{{fallbackLanguage}}` from prompts.
    ///
    /// Actions affected: Sentence Translate, Grammar Check, Sentence Analysis.
    /// Only prompts that still contain `fallbackLanguage` are replaced.
    private static func migrate_1_2_to_1_3(
        _ config: AppConfiguration
    ) -> AppConfiguration {
        var migrated = config
        migrated.version = "1.3.0"

        migrated.actions = migrated.actions.map { entry in
            guard containsFallbackLanguage(entry.prompt) else { return entry }

            var updated = entry

            if let replacement = newPromptForAction(named: entry.name) {
                updated.prompt = replacement
                Logger.debug("[Migrator] Migrated fallbackLanguage prompt for action '\(entry.name)'")
            }

            return updated
        }

        Logger.debug("[Migrator] Migration 1.2 -> 1.3 complete")
        return migrated
    }

    /// Returns `true` if the prompt contains `{fallbackLanguage}` or `{{fallbackLanguage}}`.
    static func containsFallbackLanguage(_ prompt: String) -> Bool {
        prompt.contains("{fallbackLanguage}") || prompt.contains("{{fallbackLanguage}}")
    }

    /// Returns the replacement prompt for known action names that used `fallbackLanguage`,
    /// or `nil` for unrecognized actions.
    private static func newPromptForAction(named name: String) -> String? {
        let sentenceTranslateName = NSLocalizedString(
            "Sentence Translate",
            comment: "Name of the sentence-by-sentence translation action"
        )
        let grammarCheckName = NSLocalizedString(
            "Grammar Check",
            comment: "Name of the grammar check action"
        )
        let sentenceAnalysisName = NSLocalizedString(
            "Sentence Analysis",
            comment: "Name of the sentence analysis action"
        )

        switch name {
        case sentenceTranslateName:
            return "If input is in {{targetLanguage}}, translate sentence by sentence to English; otherwise translate to {{targetLanguage}}. Return original-translation pairs. Keep meaning and style."
        case grammarCheckName:
            return "Check grammar: 1) Return polished text 2) Explain errors in {{targetLanguage}} (âŒ severe, âš ï¸ minor) 3) Translate polished meaning into {{targetLanguage}}."
        case sentenceAnalysisName:
            return "Analyze in {{targetLanguage}} using exactly these sections:\n\n## ðŸ“šè¯­æ³•åˆ†æž\n- Sentence structure (clauses, parts of speech, tense/voice)\n- Key grammar patterns\n\n## âœï¸ æ­é…ç§¯ç´¯\n- Useful phrases/collocations with brief meanings and examples\n\nBe concise. No extra sections."
        default:
            return nil
        }
    }

    // MARK: - Version comparison helpers

    /// Simple semver "less-than" check (major.minor.patch).
    private static func versionCompare(
        _ lhs: String,
        isLessThan rhs: String
    ) -> Bool {
        let l = parseVersion(lhs)
        let r = parseVersion(rhs)
        if l.major != r.major { return l.major < r.major }
        if l.minor != r.minor { return l.minor < r.minor }
        return l.patch < r.patch
    }

    private static func parseVersion(
        _ version: String
    ) -> (major: Int, minor: Int, patch: Int) {
        let parts = version.split(separator: ".").compactMap { Int($0) }
        return (
            major: parts.count > 0 ? parts[0] : 0,
            minor: parts.count > 1 ? parts[1] : 0,
            patch: parts.count > 2 ? parts[2] : 0
        )
    }
}
